Advanced compilations renames a function and then deletes it, leaving a reference to a renamed but non-existent function
If we provide the below code to advanced:      function A() {  this._x = 1;  }    A.prototype['func1'] = // done to save public reference to func1  A.prototype.func1 = function() {    this._x = 2;    this.func2();  }    A.prototype.func2 = function() {    this._x = 3;    this.func3();  }    window['A'] = A;      We get the output:      function a() {    this.a = 1  }  a.prototype.func1 = a.prototype.b = function() {    this.a = 2;    this.c() // Problem!  };  window.A = a;      So the compiler emits no errors, and renames 'func2' to 'c' but ends up throwing away the definition of that function!    The problem arises when I use:    A.prototype['func1'] = // done to save public reference to func1  A.prototype.func1 = function() {  ...  }    The ['func1'] line is apparently enough to save the reference correctly, but also has the side effect of causing the function innards to do the wrong thing.    I can of course instead write it as:    A.prototype['func1'] = A.prototype.func1;  A.prototype.func1 = function() {    this._x = 2;    this.func2();  }    In which case Advanced will compile correctly and the results will also be valid.    function a() {    this.a = 1  }  a.prototype.func1 = a.prototype.b;  a.prototype.b = function() {    this.a = 2;    this.a = 3 // func2, correctly minified  };  window.A = a;      For now I can just use the expected way of declaring that func1 export, but since the compiler returns with no errors or warnings and creates a function with no definition, it seems worth reporting.